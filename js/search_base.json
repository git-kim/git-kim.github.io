[{"categories":null,"contents":"헤더: \u0026lt;algorithm\u0026gt; 1  #include \u0026lt;algorithm\u0026gt;  주요 함수(C++20 niebloid 제외) 불변경(non-modifying) 시퀀스 연산    함수 설명     all of, any of, none of ~C++11~ 매개 변수는 (실행 정책 ~C++17~,) 범위 처음을 가리키는 반복자, 범위 끝의 바로 다음을 가리키는 반복자, unary predicate(매개 변수 하나가 쓰여 true나 false가 반환되는 함수)이다. 각각 범위 내 모든 요소를 대상으로 true가 나오는지, 범위 내 한 요소 이상을 대상으로 true가 나오는지, 범위 내 모든 요소를 대상으로 false가 나오는지 여부가 true, false로 반환된다.   for_each 매개 변수는 (실행 정책 ~C++17~,) 범위 처음을 가리키는 반복자, 범위 끝의 바로 다음을 가리키는 반복자, unary function(매개 변수가 하나 쓰이는 함수)이다. 반복자를 역참조하였을 때 나오는 요소가 unary function의 매개 변수로 쓰여야 한다. 어떤 함수를 범위 내 요소들에 적용할 때 쓴다.   for_each_n ~C++17~ 매개 변수는 (실행 정책 ~C++17~,) 반복자, 반복자가 가리키는 요소를 포함하여 함수를 적용할 요소 수, unary function(매개 변수가 하나 쓰이는 함수)이다. 어떤 함수를 어떤 요소부터 몇 요소에만 적용할 때 쓴다.   count, count_if 매개 변수는 (실행 정책 ~C++17~,) 범위 처음을 가리키는 반복자, 범위 끝의 바로 다음을 가리키는 반복자, 그리고 count면 값, count_if면 unary predicate이다. 마지막 매개 변수에 맞는(값이면 일치하는, unary predicate면 반환 값이 true인) 요소들 수가 반환된다.   mismatch 매개 변수는 (실행 정책 ~C++17~,) 범위 1 처음을 가리키는 반복자, 범위 1 끝의 바로 다음을 가리키는 반복자, 범위 2 처음을 가리키는 반복자(, 범위 2 끝의 바로 다음을 가리키는 반복자)(, binary predicate)이다. 지정한 범위에서 처음으로 일치하지 않는 두 요소의 위치를 가리키는 반복자들이 std::pair로 묶여 반환된다.   find, find_if\nfind_if_not ~C++11~ 매개 변수는 (실행 정책 ~C++17~,) 범위 처음을 가리키는 반복자, 범위 끝의 바로 다음을 가리키는 반복자, 그리고 find면 값, find_if나 find_if_not이면 unary predicate이다. 마지막 매개 변수에 맞는(값이면 일치하는, unary predicate면 반환 값이 각각 true, false인) 요소를 가리키는 반복자가 반환된다.   find_end 매개 변수는 (실행 정책 ~C++17~,) 범위 1 처음을 가리키는 반복자, 범위 1 끝의 바로 다음을 가리키는 반복자, 범위 2 처음을 가리키는 반복자, 범위 2 끝의 바로 다음을 가리키는 반복자(, binary predicate)이다. 범위 2 시퀀스가 범위 1에서 마지막으로 나타나는 위치를 찾을 때 쓴다. 범위 2가 비어 있거나 범위 2 시퀀스가 범위 1에 존재하지 않을 때에는 범위 1 끝의 바로 다음을 가리키는 반복자가 반환되며, 범위 2 시퀀스가 범위 1에 존재할 때에는 마지막으로 그 시퀀스가 나타나는 위치(첫 요소 기준)를 가리키는 반복자가 반환된다.   find_first_of 매개 변수는 (실행 정책 ~C++17~,) 범위 1 처음을 가리키는 반복자, 범위 1 끝의 바로 다음을 가리키는 반복자, 범위 2 처음을 가리키는 반복자, 범위 2 끝의 바로 다음을 가리키는 반복자(, binary predicate)이다. Binary predicate를 지정하지 않았을 때에는 범위 1에서 범위 2 요소와 같은 요소가 발견되면 그 위치(범위 1 대상)를 가리키는 반복자가 반환된다. int 요소에 쓸 수 있는 binary predicate의 예로 std::less\u0026lt;int\u0026gt;()가 있으며 이 함수를 쓰면 범위 1에서 범위 2 요소보다 작은 요소가 발견되었을 때 그 위치(범위 1 대상)를 가리키는 반복자가 반환된다.   adjacent_find 매개 변수는 (실행 정책 ~C++17~,) 범위 처음을 가리키는 반복자, 범위 끝의 바로 다음을 가리키는 반복자(, binary predicate)이다. Binary predicate를 지정하지 않았을 때에는 같은 요소가 연달아 존재하는 위치(둘 중 첫 요소)를 가리키는 반복자가 반환된다. int 요소에 쓸 수 있는 binary predicate의 예로 std::greater\u0026lt;int\u0026gt;()가 있으며 이 함수를 쓰면 인접 요소끼리 비교되어 둘 중 작은 수가 뒤에 있는 쌍의 위치(둘 중 첫 요소)를 가리키는 반복자가 반환된다.   search 매개 변수는 (실행 정책 ~C++17~,) 범위 1 처음을 가리키는 반복자, 범위 1 끝의 바로 다음을 가리키는 반복자, 범위 2 처음을 가리키는 반복자, 범위 2 끝의 바로 다음을 가리키는 반복자(, binary predicate)이다. 다만 범위 2 반복자들을 searcher(boyer_moore_searcher ~C++17~,  boyer_moore_horspool_searcher ~C++17~ 등)에 써서 그 searcher를 세 번째 인수로 지정할 수도 있다(~C++17~). 범위 2로 지정한 요소 시퀀스가 범위 1에 존재하면 그 위치(범위 1 대상)를 가리키는 반복자가 반환된다.   search_n 매개 변수는 (실행 정책 ~C++17~,) 범위 처음을 가리키는 반복자, 범위 끝의 바로 다음을 가리키는 반복자, 개수, 값(, binary predicate)이다. Binary predicate를 지정하지 않았을 때에는 범위 내에서 지정한 개수만큼 지정한 값이 연달아 존재하는 위치를 가리키는 반복자가 반환된다. Binary predicate를 지정하였을 때에는 지정한 값과 범위 내 각 요소 값이 그 함수로 비교되어 그 함수에서 true가 지정한 개수만큼 연달아 반환되는 위치를 가리키는 반복자가 반환된다.    변경(modifying) 시퀀스 연산    함수 설명1     copy '지정 범위' 안에 있는 요소를 복사하여 '지정 위치'부터 넣기   copy_n ~C++11~ '지정 범위' 안에 있는 요소를 복사하여 '지정 위치'부터 넣기   copy_if ~C++11~ '지정 범위' 안에 있으면서 '지정 기준'을 충족하는 요소를 복사하여 '지정 위치'부터 넣기(참고: JavaScript filter와 유사하다.)   copy_backward '지정 범위' 안에 있는 요소를 복사하여 '지정 위치' 바로 전까지 채워지도록 넣기(주의: 요소 순서는 변하지 않는다.)   move ~C++11~ '지정 범위' 안에 있는 요소를 이동하여 '지정 위치'부터 넣기(참고: 원 요소가 있던 공간이 비게 된다.)   move_backward ~C+11~ '지정 범위' 안에 있는 요소를 이동하여 '지정 위치' 바로 전까지 채워지도록 넣기(주의: 요소 순서는 변하지 않는다. 참고: 원 요소가 있던 공간이 비게 된다.)   fill '지정 값'을 '지정 범위' 안에 복사 대입(copy assignment) 하기   fill_n '지정 값'을 '지정 범위' 안에 복사 대입 하기   transform '지정 범위'(와 '지정 위치'로 시작하는 범위) 안에 있는 요소를 대상으로 '지정 함수'를 호출하여 그 함수에서 반환되는 값을 '지정 위치'부터 넣기(참고: JavaScript map과 유사하다.)   generate '지정 함수'를 거듭 호출하면서 그 함수에서 반환되는 값을 '지정 범위' 안에 순차로 대입하기(예를 들어 std::generate(v.begin(), v.end(), [n = 0] () mutable { return n++; });은 std::iota(v.begin(), v.end(), 0);과 동일한 기능을 한다. 참고: mutable이 있어야 램더 식(lambda expression)에서 변수 값을 변경할 수 있다.)   generate_n '지정 함수'를 거듭 호출하면서 그 함수에서 반환되는 값을 '지정 범위' 안에 순차로 대입하기   remove '지정 범위' 안에 있으면서 '지정 값'과 같은 요소를 제거하기   remove_if '지정 범위' 안에 있으면서 '지정 기준'을 충족하는 요소를 제거하기   remove_copy '지정 범위' 안에 있는 요소를 복사하여 '지정 위치'부터 넣되 '지정 값'과 같은 요소를 제거하기   remove_copy_if '지정 범위' 안에 있는 요소를 복사하여 '지정 위치'부터 넣되 '지정 기준'을 충족하는 요소를 제거하기   replace '지정 값'과 같은 요소를 전부 동일한 '지정 값'으로 변경하기   replace_if '지정 기준'을 충족하는 요소를 전부 동일한 '지정 값'으로 변경하기   replace_copy '지정 범위' 안에 있는 요소를 복사하여 '지정 위치'부터 넣되 '지정 값'과 같은 요소를 전부 동일한 '지정 값'으로 변경하기   replace_copy_if '지정 범위' 안에 있는 요소를 복사하여 '지정 위치'부터 넣되 '지정 기준'을 충족하는 요소를 전부 동일한 '지정 값'으로 변경하기   swap '지정 값'과 '지정 값'을 교환하기   swap_ranges '지정 범위' 안에 있는 요소와 '지정 위치'부터 있는 요소를 교환하기   iter_swap '지정 위치'에 있는 요소와 '지정 위치'에 있는 요소를 교환하기(참고: std::min_element를 함께 써서 선택 정렬을 하는 데에 쓸 수 있다.)   reverse '지정 범위' 안에 있는 요소의 순서를 뒤집기   reverse_copy '지정 범위' 안에 있는 요소를 복사하여 '지정 위치'부터 넣되 요소 순서를 뒤집기(참고: 범위를 지정할 때 rbegin과 rend를 쓰면 요소 순서가 본래 순서와 같게 된다.)   rotate '지정 위치'에 있는 요소를 축으로 '지정 범위' 안에 있는 요소를 두 집단으로 보아 집단을 교환하기(참고: std::upper_bound를 함께 써서 삽입 정렬을 하는 데에 쓸 수 있다.)   rotate_copy '지정 범위' 안에 있는 요소를 복사하여 '지정 위치'부터 넣되 '지정 위치'에 있는 요소를 축으로 '지정 범위' 안에 있는 요소를 두 집단으로 보아 집단을 교환하기   shift_left, shift_right ~C++20~ '지정 범위' 안에 있는 요소 위치를 '지정 숫자'만큼 이동하기(참고: '지정 범위'를 벗어나는 요소는 제거된다.)   random_shuffle ~deprecated~ ~in~ ~C++14~ shuffle ~C++11~ '지정 범위' 안에 있는 요소를 무작위 순서로 다시 나열하기(이제는 무작위 수 생성기를 지정하여야 한다.)   sample ~C++17~ '지정 범위'에서 무작위로 요소를 '지정 개수'만큼 추출하여 '지정 위치'부터 넣기(무작위 수 생성기를 지정하여야 한다.)   unique '지정 범위'에 연속으로 동일한 요소가 있으면 동일한 요소를 하나만 남기기(참고: 두 요소를 같다고 볼 '기준'을 지정할 수도 있다.)   unique_copy '지정 범위' 안에 있는 요소를 복사하여 '지정 위치'부터 넣되 '지정 범위'에 연속으로 동일한 요소가 있으면 동일한 요소를 하나만 남기기(참고: 두 요소를 같다고 볼 '기준'을 지정할 수도 있다.)    분할(partitioning) 연산    함수 설명     is_partitioned ~C++11~ '지정 기준'을 충족하는 요소들이 전부 '지정 범위' 앞부분에 있고 충족하지 않는 요소들이 뒷부분에 있는지 확인하기2   partition '지정 기준'을 충족하는 요소들을 전부 '지정 범위' 앞부분에 있게 하기   partition_copy ~C++11~ '지정 범위' 안에 있는 요소를 복사하여 '지정 기준'을 충족하는 요소들을 전부 '지정 위치'부터 넣고, 충족하지 않는 요소들을 다른 '지정 위치'부터 넣기   stable_partition '지정 기준'을 충족하는 요소들을 전부 '지정 범위' 앞부분에 있게 하되 요소 간 상대 순서를 유지하기3   partition_point ~C++11~ '지정 기준'을 충족하는 마지막 요소의 바로 다음 요소 위치를 알아내기    정렬(sorting) 연산    함수 설명     is_sorted ~C++11~ '지정 범위' 안에 있는 요소들이 값이 작아지지 않는 순서로 있는지 검사하기(추가로 비교 '기준'을 지정하여 줄 수도 있다.)   is_sorted_until ~C++11~ '지정 범위' 안에서 바로 앞 요소보다 값이 작은 첫 요소의 위치를 알아내기(반복자가 반환된다. 추가로 비교 '기준'을 지정하여 줄 수도 있다.)   sort '지정 범위' 안에 있는 요소들을 값이 작아지지 않는 순서로 있도록 정렬하기(추가로 비교 '기준'을 지정하여 줄 수도 있다. 예를 들어 std::greater\u0026lt;int\u0026gt;()을 지정하면 int 요소들을 값이 커지지 않는 순서로 있도록 정렬할 수 있다.)4   partial_sort 첫 '지정 위치'부터 세 번째 '지정 위치' 직전까지 범위 안에 있는 요소 중에서 작은 값이 있는 요소가 첫 '지정 위치'부터 두 번째 '지정 위치' 직전까지 범위 안에 값이 작아지지 않는 순서로 있게 하기(요소 간 상대 순서는 보존되지 않는다. 추가로 비교 '기준'을 지정하여 줄 수도 있다.)5   partial_sort_copy '지정 범위'에 있는 요소들을 복사하여 다른 '지정 범위'에 넣고 그 요소들만 정렬하기(범위 크기가 다르면 작은 쪽에 맞춘다. 추가로 비교 '기준'을 지정하여 줄 수도 있다.)   stable_sort '지정 범위' 안에 있는 요소들을 값이 작아지지 않는 순서로 있도록 정렬하되 요소 간 상대 순서를 유지하기(추가로 비교 '기준'을 지정하여 줄 수도 있다.)6   nth_element '지정 범위' 안에 있는 요소들을 비교하여 '지정 위치'에 있어야 할 요소보다 값이 작은 요소는 그 요소 앞에, 같거나 큰 요소는 뒤에 오도록 요소들을 '지정 위치'를 기준으로 분리하기(요소가 전부 정렬되지는 않는다. 분할 연산이라 볼 수도 있겠다. 추가로 비교 '기준'을 지정하여 줄 수도 있다. 중간값이나 n 번째로 작거나 큰 값을 구할 때 유용하다.)    이진 탐색(binary search) 연산 (정렬된 범위에 사용한다.)    함수 설명     lower_bound '지정 범위' 안에서 값이 '지정 값'과 같거나 그 값보다 큰 요소의 위치를 알아내기(추가로 비교 '기준'을 지정하여 줄 수도 있다. 주의: 수학에서 말하는 하계와는 다르다.)   upper_bound '지정 범위' 안에서 값이 '지정 값'보다 큰 요소의 위치를 알아내기(추가로 비교 '기준'을 지정하여 줄 수도 있다. 주의: 수학에서 말하는 상계와는 다르다.)   binary_search '지정 범위' 안에 있는 요소 중에 값이 '지정 값'과 같은 요소가 있는지 확인하기(추가로 비교 '기준'을 지정하여 줄 수도 있다.)   equal_range '지정 범위'와 '지정 값'에 맞는 lower_bound와 upper_bound를 pair로 반환시키기(추가로 비교 '기준'을 지정하여 줄 수도 있다.)    집합(set) 연산 (정렬된 범위에 사용한다.)    함수 설명     includes 두 번째 '지정 범위' 안에 있는 요소들이 첫 번째 '지정 범위' 안에 있는 요소들로 구성되는 부분열(subsequence)인지 검사하기(추가로 비교 '기준'을 지정하여 줄 수도 있다. 예를 들어 {'a', 'c'}는 {'a', 'b', 'c'}의 부분열이지만 {'c', 'a'}는 아니기 때문에 이 함수를 사용하기 전에 정렬을 하여야 한다.)   set_difference 두 '지정 범위' 집합의 차집합을 '지정 위치'에 만들기(추가로 비교 '기준'을 지정하여 줄 수도 있다.)   set_intersection 두 '지정 범위' 집합의 교집합을 '지정 위치'에 만들기(추가로 비교 '기준'을 지정하여 줄 수도 있다.)   set_symmetric_difference 두 '지정 범위' 집합의 대칭 차집합을 '지정 위치'에 만들기(추가로 비교 '기준'을 지정하여 줄 수도 있다.)   set_union 두 '지정 범위' 집합의 합집합을 '지정 위치'에 만들기(추가로 비교 '기준'을 지정하여 줄 수도 있다.)    정렬된 범위에 사용하는 다른 연산    함수 설명     merge 두 정렬된 '지정 범위'를 병합하되 값이 작아지지 않는 순서로 요소들이 있도록 '지정 위치'에 만들기(추가로 비교 '기준'을 지정하여 줄 수도 있다.)   inplace_merge 첫 두 '지정 위치'에 해당하는 범위와 두 번째 '지정 위치', 세 번째 '지정 위치'에 해당하는 범위를 병합하되 값이 작아지지 않는 순서로 요소들이 있게 하기(추가로 비교 '기준'을 지정하여 줄 수도 있다. 참고: 이 함수를 사용하여 merge sort를 구현할 수 있다.)    히프(heap) 연산    함수 설명     is_heap ~C++11~ '지정 범위' 안에 있는 요소들이 최대 히프(부모 노드 값이 자식 노드 값보다 크거나 자식 노드 값과 같은 이진 트리)를 이루는지 검사하기(추가로 비교 '기준'을 지정하여 줄 수도 있다.)   is_heap_until ~C++11~ '지정 범위' 안에서 최대 히프가 끝나는 바로 다음 '위치'를 알아내기(추가로 비교 '기준'을 지정하여 줄 수도 있다.)   make_heap '지정 범위' 안에 있는 요소들이 최대 히프를 이루게 하기(추가로 비교 '기준'을 지정하여 줄 수도 있다. 예를 들어 std::greater\u0026lt;\u0026gt;{}가 비교 기준이면 요소들은 최소 히프를 이루게 된다.)   push_heap '지정 범위' 안에서 마지막 요소를 제외하고 최대 히프를 이루고 있을 때 그 요소 포함하여 최대 히프를 이루게 하기(추가로 비교 '기준'을 지정하여 줄 수도 있다.)   pop_heap '지정 범위' 안에서 최대 히프 최상위 노드에 해당하는 요소를 마지막 요소와 교환한 후 마지막 요소를 제외하고 나머지 요소들이 최대 히프를 이루게 하기(추가로 비교 '기준'을 지정하여 줄 수도 있다.)   sort_heap '지정 범위' 최대 히프를 오름차순으로 정렬된 요소들이 있는 범위로 변환하기(추가로 비교 '기준'을 지정하여 줄 수도 있다.)    최대·최소 연산    함수 설명     max 두 값 중 큰 값 찾기 또는 초기화 목록에서 가장 큰 값 찾기(추가로 비교 '기준'을 지정하여 줄 수도 있다.)   max_element '지정 범위'에서 가장 큰 값이 있는 요소의 위치를 찾기(추가로 비교 '기준'을 지정하여 줄 수도 있다.)   min 두 값 중 작은 값 찾기 또는 초기화 목록에서 가장 작은 값 찾기(추가로 비교 '기준'을 지정하여 줄 수도 있다.)   min_element '지정 범위'에서 가장 작은 값이 있는 요소의 위치를 찾기(추가로 비교 '기준'을 지정하여 줄 수도 있다.)   minmax ~C++11~ 두 값 중 작은 값과 큰 값을 pair로 반환시키기 또는 초기화 목록에서 가장 작은 값과 가장 큰 값을 pair로 반환시키기(추가로 비교 '기준'을 지정하여 줄 수도 있다.)   minmax_element ~C++11~ '지정 범위'에서 가장 작은 값이 있는 요소의 위치와 가장 큰 값이 있는 요소의 위치를 pair로 반환시키기(추가로 비교 '기준'을 지정하여 줄 수도 있다.)   clamp ~C++17~ 첫 '지정 값'이 두 번째 '지정 값'보다 작으면 두 번째 '지정 값'을, 세 번째 '지정 값'보다 크면 세 번째 '지정 값'을, 아니면 첫 '지정 값'을 반환시키기(어떤 변숫값의 한계를 지정할 때 유용하다. 추가로 비교 '기준'을 지정하여 줄 수도 있다.)    비교 연산    함수 설명     equal 두 '지정 범위' 요소들이 같은지 확인하기(두 범위는 세 반복자나 네 반복자를 사용하여 지정한다. 회문(palindrome)을 찾을 때 유용하다. 추가로 비교 '기준'을 지정하여 줄 수도 있다.)   lexicographical_compare ~C++20~ 사전식으로 비교하여 첫 '지정 범위'가 두 번째 '지정 범위'보다 작은지 확인하기(각 범위는 두 반복자를 사용하여 지정한다. 추가로 비교 '기준'을 지정하여 줄 수도 있다.)   lexicographical_compare_three_way ~C++20~ 두 '지정 범위'를 사전식으로 비교하여 정수 리터럴 0과 비교될 수 있는 값 하나(std::strong_ordering::greater, std::strong_ordering::less, std::strong_ordering::equal 중 하나)를 반환시키기(추가로 비교 '기준'을 지정하여 줄 수도 있다.)7    순열(permutation) 연산    함수 설명     is_permutation ~C++11~ '지정 범위' 안에 있는 요소들로 '지정 위치' 요소부터 시작하는 시퀀스(또는 다른 '지정 범위' 안의 요소들이 이루는 시퀀스)를 만들 수 있는지 확인하기(추가로 비교 '기준'을 지정하여 줄 수도 있다.)   next_permutation 사전식으로 비교하였을 때 '지정 범위' 순열의 바로 다음인 순열을 만들기(사전식으로 이미 마지막이면 false가 반환된다. 추가로 비교 '기준'을 지정하여 줄 수도 있다.)   prev_permutation 사전식으로 비교하였을 때 '지정 범위' 순열의 바로 전인 순열을 만들기(사전식으로 이미 처음이면 false가 반환된다. 추가로 비교 '기준'을 지정하여 줄 수도 있다.)    수(numeric) 연산    함수 설명     iota ~C++11~ '지정 범위'를 '지정 값'부터 순차로 증가하게 채우기   accumulate '지정 범위' 안에 있는 요소의 값을 '지정 값'(초깃값)에 누적하여 더하고 그렇게 나온 값을 반환시키기(추가로 적용할 '함수'를 지정하여 줄 수도 있다. 그러나 실행 정책을 지정할 수 없다. 예를 들어 '지정 값'이 1이고 '지정 함수'가 std::multiplies\u0026lt;int\u0026gt;()이면 누계가 아니라 누적 곱이 나온다.)   inner_product '지정 범위' 안에 있는 요소들과 '지정 위치'부터 시작하는 범위 안에 있는 요소들을 내적하여 나온 값을 반환시키기(추가로 적용할 두 '함수'를 지정하여 줄 수도 있는데 첫 함수는 더하기 자리에 적용할 함수를, 두 번째 함수는 곱하기 자리에 적용할 함수를 지정하여야 한다. 예를 들어 '지정 함수들'이 std::plus\u0026lt;\u0026gt;(), std::equal_to\u0026lt;\u0026gt;()이면 동일한 값이 있으면서 상대 위치가 같은 요소가 몇 쌍인지 알 수 있다.)   adjacent_difference '지정 범위' 첫 요소의 값은 그대로 '지정 위치'에 넣고 그 다음부터는 해당 위치 요소 값에서 바로 전 요소의 값을 감산하여 넣기(추가로 적용할 '함수'를 지정하여 줄 수도 있다. 예를 들어 std::plus\u0026lt;\u0026gt; {} 함수를 사용하면 피보나치수열도 만들 수 있다.)   partial_sum '지정 범위' 첫 요소의 값은 그대로 '지정 위치'에 넣고 그 다음부터는 해당 위치 요소 값에 전(前) 요소들의 값을 전부 가산하여 넣기(제곱수를 나열할 때 유용하다. 추가로 적용할 '함수'를 지정하여 줄 수도 있다. 그러나 실행 정책을 지정할 수 없다.)   reduce ~C++17~ 실행 정책~C++17~을 지정하여 병렬 처리가 가능한 std::accumulate(주의: \u0026lt;numeric\u0026gt;에 정의되어 있다. 참고: JavaScript reduce와 유사하다.)   exclusive_scan ~C++17~ 실행 정책~C++17~ 지정이 가능하고 계산 시 해당 위치 요소의 값은 포함되지 않는 std::partial_sum(즉 '지정 위치' 첫 요소 값은 초깃값이다.)   inclusive_scan ~C++17~ 실행 정책~C++17~ 지정이 가능하고 계산 시 해당 위치 요소의 값이 포함되는 std::partial_sum(즉 '지정 위치' 첫 요소 값은 '지정 범위' 첫 요소 값이다.)   transform_reduce ~C++17~ std::transform, std::reduce를 연달아 사용하기   transform_exclusive_scan ~C++17~ std::transform, std::exclusive_scan을 연달아 사용하기   transform_inclusive_scan ~C++17~ std::transform, std::inclusive_scan을 연달아 사용하기    초기화하지 않은 메모리에 사용하는 연산    함수 설명     uninitialized_copy '지정 범위' 객체들(값들)을 '지정 위치'로 시작하는 초기화하지 않은 메모리 공간에 복사하여 넣기(반환 값은 복사되어 넣어진 마지막 요소의 바로 다음 위치를 가리키는 반복자이다.)   uninitialized_copy_n '지정 범위' 객체들(값들)을 '지정 위치'로 시작하는 초기화하지 않은 메모리 공간에 복사하여 넣기(반환 값은 복사되어 넣어진 마지막 요소의 바로 다음 위치를 가리키는 반복자이다.)   uninitialized_fill 초기화하지 않은 '지정 범위' 메모리 공간을 '지정 값'(지정 객체)로 채우기   uninitialized_fill_n 초기화하지 않은 '지정 범위' 메모리 공간을 '지정 값'(지정 객체)로 채우기   uninitialized_move ~C++17~ '지정 범위' 객체들(값들)을 '지정 위치'로 시작하는 초기화하지 않은 메모리 공간으로 이동하기   uninitialized_move_n ~C++17~ '지정 범위' 객체들(값들)을 '지정 위치'로 시작하는 초기화하지 않은 메모리 공간으로 이동하기   uninitialized_default_construct ~C++17~ 초기화하지 않은 '지정 범위' 메모리 공간에 기본 초기화 방식으로 객체를 생성하기   uninitialized_default_construct_n ~C++17~ 초기화하지 않은 '지정 범위' 메모리 공간에 기본 초기화 방식으로 객체를 생성하기   uninitialized_value_construct ~C++17~ 초기화하지 않은 '지정 범위' 메모리 공간에 값 초기화 방식으로 객체를 생성하기   uninitialized_value_construct_n ~C++17~ 초기화하지 않은 '지정 범위' 메모리 공간에 값 초기화 방식으로 객체를 생성하기   destroy ~C++17~ '지정 범위' 객체를 소멸시키기   destroy_n ~C++17~ '지정 범위' 객체를 소멸시키기   destroy_at ~C++17~ '지정 주소' 객체를 소멸시키기   construct_at ~C++20~ '지정 주소'에 객체를 생성하기     참조 cppreference.com\n   주소를 담는 객체인 반복자(iterator)로 '위치'를 지정하며, 함수명에 _n이 있을 때에는 시작 위치 반복자와 요소 개수로, _n이 없을 때에는 시작 위치 반복자와 끝 다음 위치 반복자로 '범위'를 지정한다. 함수로 '기준'을 지정한다. \u0026#x21a9;\u0026#xfe0e;\n '앞부분'과 '뒷부분'은 범위를 begin(), end() 쌍(또는 cbegin(), cend() 쌍)으로 지정하느냐 rbegin(), rend() 쌍(또는 crbegin(), crend() 쌍)으로 지정하느냐에 따라 다르다. \u0026#x21a9;\u0026#xfe0e;\n 요소 간 상대 순서를 유지한다는 의미로 함수명에 stable이 있다. \u0026#x21a9;\u0026#xfe0e;\n Introsort(quicksort, heapsort, insertion sort)가 사용된다고 한다. \u0026#x21a9;\u0026#xfe0e;\n Heapsort가 사용된다고 한다. \u0026#x21a9;\u0026#xfe0e;\n Bottom-up merge sort와 insertion sort가 사용된다고 한다. \u0026#x21a9;\u0026#xfe0e;\n 우주선 연산자와 관련이 있다. \u0026#x21a9;\u0026#xfe0e;\n   ","date":"2020-11-23","permalink":"https://git-kim.github.io/posts/c++-%EC%95%A8%EA%B1%B0%EB%A6%AC%EB%93%ACalgorithm/","tags":null,"title":"C++ 앨거리듬(algorithm)"},{"categories":null,"contents":"헤더: \u0026lt;string\u0026gt; 1  #include \u0026lt;string\u0026gt;  주요 자료형 자료형과 리터럴    자료형 (이름 공간: std) 관련 스트링 리터럴 예 스트링 리터럴 부호화 형식 스트링 리터럴 자료형1     string\n:= basic_string\u0026lt;char\u0026gt; \u0026quot;abc\u0026quot; narrow encoding\n(사용 환경마다 다름)2 const char[n]   u8string ~C++20~ := basic_string\u0026lt;char8_t\u0026gt; u8\u0026quot;abc\u0026quot; UTF-8 const char[n]\nconst char8_t[n] ~(C++20)~   u16string ~C++11~ := basic_string\u0026lt;char16_t\u0026gt; u\u0026quot;abc\u0026quot; UTF-163 const char16_t[n] ~(C++11)~   u32string ~C++11~ := basic_string\u0026lt;char32_t\u0026gt; U\u0026quot;abc\u0026quot; UTF-32 const char32_t[n] ~(C++11)~   wstring\n:= basic_string\u0026lt;wchar_t\u0026gt; L\u0026quot;abc\u0026quot; wide encoding\n(사용 환경마다 다름)4 const wchar_t[n]     std::basic_string은 순서대로 나열된 문자들을 다루거나 저장하는 데 쓰는 컨테이너(container)이자 클래스 템플릿(class template)이다.  참고: 몇 가지 부호화 형식  ASCII (American Standard Code for Information Interchange): 7 bits를 쓰는 부호화 형식(코드 포인트 128 개이다.)이며 한 문자는 1 byte 공간(1 bit는 전송 오류를 검사할 때 쓰는 패러티 비트(parity bit)이다.)을 차지한다.  Extended ASCII (EASCII): 보통 한 문자가 8 bits(즉 1 byte)를 쓰는 부호화 형식(코드 포인트 255 개)을 일컫는다. UTF-8을 일컬을 때도 있다.   UTF-8: 가변 길이 부호화 형식이며 코드 포인트마다 1 byte에서 4 bytes까지 공간(코드 유닛마다 1 byte 공간)을 차지한다. ASCII 문자 하나는 1 byte 공간을 차지하며 한글 한 자는 3 bytes 공간을 차지하고 그림 문자 하나는 4 bytes 공간을 차지한다. \u0026quot;가나다라마바사아\u0026quot;라는 문자열 리터럴은 24 코드 유닛(8 코드 포인트)이므로 n이 25인 const char8_t 문자열(널 문자도 담아야 한다.)에 담길 수 있다. \u0026quot;😊\u0026quot;라는 문자열 리터럴은 4 코드 유닛(1 코드 포인트)이므로 n이 5인 const char8_t 문자열에 담길 수 있다. UTF-16: 가변 길이 부호화 형식이며 코드 포인트가 한두 코드 유닛(코드 유닛마다 2 bytes 공간을 차지한다.)으로 구성된다. 다국어 기본 평면에 속하는 영문자, 한글 등은 2 bytes 공간을 차지하지만 다국어 보조 평면에 속하여 surrogate pair로 표현되는 그림 문자는 4 bytes 공간을 차지한다. \u0026quot;가나다라마바사아\u0026quot;라는 문자열 리터럴은 8 코드 유닛(8 코드 포인트)이므로 n이 9인 const char16_t 문자열(널 문자도 담아야 한다.)에 담길 수 있다. \u0026quot;😊\u0026quot;라는 문자열 리터럴은 2 코드 유닛(1 코드 포인트)이므로 n이 3인 const char16_t 문자열에 담길 수 있다. UTF-32: 고정 길이 부호화 형식이며 코드 포인트마다 4 bytes 공간(코드 유닛마다 4 bytes 공간)을 차지한다. \u0026quot;가나다라마바사아\u0026quot;라는 문자열 리터럴은 8 코드 유닛(8 코드 포인트)이므로 n이 9인 const char32_t 문자열(널 문자도 담아야 한다.)에 담길 수 있다. \u0026quot;😊\u0026quot;라는 문자열 리터럴은 1 코드 유닛(1 코드 포인트)이므로 n이 2인 const char32_t 문자열에 담길 수 있다.  주요 연산자·함수 이름 공간 std::basic_string\u0026lt;CharT,Traits,Allocator\u0026gt;에 속하는 연산자·함수를 '멤버'로 분류하면 아래와 같은 연산자·함수들이 있다.\n연산자    비멤버 연산자 설명     + 두 스트링을 연결하거나 스트링과 문자를 연결할 때 쓴다. 연결된 스트링이 반환된다.   == 두 스트링이 사전식으로 비교되어 두 스트링이 같으면 true가 같지 않으면 false가 반환된다.5   \u0026lt;=\u0026gt; ~C++20~ 두 스트링이 사전식으로 비교되어 정수 리터럴 0과 비교될 수 있는 값 하나가 반환된다.6   \u0026quot;\u0026quot;s 문자열 리터럴이 요구되는 자료형에 맞는 스트링 리터럴로 변하여 반환된다. 문자열 리터럴에 널 문자를 포함할 수 있다.7 특정 이름 공간을 사용함으로써 이 연산자를 쓸 수 있다.8   \u0026lt;\u0026lt; 스트링 변수에 저장된 스트링을 출력할 때 쓴다. 출력 스트림이 반환된다.   \u0026gt;\u0026gt; 스트링을 스트링 변수에 저장할 때 쓴다. 입력 스트림이 반환된다.     문자열 리터럴끼리 연결할 때에는 연산자가 없어도 되지만(예: \u0026quot;Hello \u0026quot;\u0026quot;World!\u0026quot;) 스트링 변수끼리 연결할 때나 스트링 변수와 문자열 리터럴을 연결할 때에는 연산자(+)가 필요하다. 숫자 리터럴·변수와 문자열 리터럴을 연결하려면 std::to_string 함수를 숫자 리터럴·변수에 써야 한다(다른 방법도 물론 있다.). 문자열 리터럴이 문자열 주소를 반환하기 때문에 std::cout \u0026lt;\u0026lt; \u0026quot;Hello, Hero\u0026quot; + 7;처럼 쓰면 Hero만 출력된다. 필자는 '사전식 비교'를 잘못된 표현이라고 본다. 필자가 쓰는 컴파일러를 기준으로 \u0026quot;B\u0026quot;가 \u0026quot;a\u0026quot;보다 작은 것만 봐도 '사전식 비교'는 아니다. 해당 부호화 방식을 기준으로 첫 문자부터 코드 포인트마다 코드(부호)를 비교한다고 표현하는 편이 낫지 않을까 한다. 컴파일러가 UTF-8을 부호화 형식으로 하고 ASCII 코드 문자만이 있는 스트링이 비교된다면 각 문자에 해당하는 ASCII 코드가 비교된다고 볼 수 있다. 이렇게 생각하면 \u0026quot;B\u0026quot;(B의 ASCII 코드: 66)가 \u0026quot;a\u0026quot;(a의 ASCII 코드: 97)보다 작은 것이 이해가 된다. C++20에서 비교 연산자를 다룰 때 알아 둘 점이 있다.  동일 여부를 비교하는 연산자 중 일차(primary) 연산자는 ==이고 부차(secondary) 연산자는 !=이다. 크기 비교 연산자 중 일차(primary) 연산자는 \u0026lt;=\u0026gt;이고 부차(secondary) 연산자는 \u0026lt;, \u0026gt;, \u0026lt;=, \u0026gt;=이다. 일차 연산자를 정의하였으면 부차 연산자는 정의할 필요가 없다. 일차 연산자에 한하여 연산자 앞뒤에 오는 값의 순서가 바뀌어도 된다. 예를 들어 a == 1에 쓸 수 있는 == 연산자를 정의하였다면 그 정의만으로 1 == a 연산이 가능하다. 이차 연산자를 정의하면 이차 연산자가 일차 연산자를 '이긴다'. 예를 들어 == 연산자와 != 연산자를 둘 다 정의하면 a != b는 !a.operator==(b)나 !b.operator==(a)가 아니라 a.operator!=(b)로 해석된다. \u0026lt;=\u0026gt; 연산자를 default로 정의하였으면 == 연산자 정의를 명시하지 않아도 == 연산자가 default로 정의된다. \u0026lt;=\u0026gt; 연산자를 정의하였으나 default로 정의하지 않았으면 == 연산자는 저절로 정의되지 않는다. \u0026lt;=\u0026gt; 연산자 반환 자료형(auto로 지정하여도 된다.)은 strong_ordering 또는 weak_ordering, partial_ordering이며, == 연산자 반환 자료형은 당연히 bool이다.       멤버 연산자 설명     [] 특정 위치에 있는 문자를 가리키는 참조자가 반환된다. 참조자가 반환되므로 해당 위치 문자를 다른 문자로 변경할 수 있다. 소속 이름 공간은 std::basic_string\u0026lt;CharT, Traits, Allocator\u0026gt;이다.   += 스트링 끝에 문자나 문자들을 붙일 때 쓴다.    입출력(연산자 제외)    비멤버 함수\n(이름 공간: std) 설명     getline 스트링 변수에 저장할 문자들을 구분자 직전까지 한 단위로 입력받을 때, 아니면 std::istrigstream 변수에 저장된 스트링에서 구분자 직전까지 있는 문자들을 한 단위로 이용하려고 할 때 쓴다. for 문 조건식으로서 자리할 수 있는 함수다. 매개 변수는 문자 입력 스트림, 한 단위가 저장되는 스트링 변수, 구분자(delimiter)(생략 가능)이며, 기본 구분자는 개행 문자이다.    수 변환    비멤버 함수\n(이름 공간: std) 설명     stoi, stol, stoll 내부에 숫자만 있거나 공백 문자를 제외하고 숫자가 먼저 나오는 스트링(여기서는 '스트링 숫자'라고 하겠다.)을 부호 있는 정수(signed integer) 값으로 변환할 때 쓴다. stoi, stol, stoll은 a string to an int, a string to a long, a string to a long long이라고 이해하면 쉽다. stoi나 stol이나 strtol 또는 wcstol 함수를 호출한다는 점에서 같다. stoll은 strtoll 또는 wcstoll을 호출한다. 스트링 숫자는 실수여도 되며(어차피 소수점 뒤는 무시된다.) 앞에 +, -가 붙어 있어도 된다. 스트링 숫자에 대응되는 정수 값이 반환된다. 매개 변수는 변환 대상 스트링, std::size_t형 변수 주소(정수로 변환된 문자 수가 지정한 변수에 저장된다.), 진법을 나타내는 수(base)이다. 변환된 문자 수를 알 필요가 없다면 두 번째 인수를 지정하지 않거나(세 번째 인수를 쓰지 않을 때에만 지정하지 않을 수 있다.) 0(기본값), nullptr로 지정할 수 있으며 스트링에 있는 숫자가 10진수가 아니라 16진수거나 8진수이면 세 번째 인수를 각각 16, 8로 지정하면 된다. 세 번째 인수를 0이나 8로 하면 0이 앞에 붙은 스트링 숫자는 8진수로 해석되고 0이나 16으로 하면 0x나 0X가 앞에 붙은 스트링 숫자는 16진수로 해석된다.   stoul, stoull 스트링 숫자를 부호 없는 정수(unsigned integer) 값으로 변환할 때 쓴다. (반환형, 매개 변수 설명은 생략한다.)   stof, stod, stold 스트링 숫자를 실수 값으로 변환할 때 쓴다. stof는 strtof 또는 wcstof를 호출한다.... 매개 변수는 변환 대상 스트링과 std::size_t형 변수 주소만 있다. 스트링 숫자가 될 수 있는 문자열 예로는 \u0026quot;+1.1E+10\u0026quot;, \u0026quot;-0x0.3p10\u0026quot;, \u0026quot;-INF\u0026quot;, \u0026quot;NAN\u0026quot; 등이 있으며 대소문자는 중요하지 않다.   to_string, to_wstring 숫자 값을 각각 std::string, std::wstring 스트링으로 변환할 때 쓴다.    범위 접근    비멤버 함수\n(이름 공간: std) 설명     begin ~C++11~ cbegin ~C++14~ 매개 변수 스트링의 첫 요소(문자)를 가리키는 반복자(iterator)가 반환된다. 반복자를 쓰면서 요소를 변경하지 않으려면 cbegin을 쓰는 편이 좋다.   end ~C++11~ cend ~C++14~ 매개 변수 스트링의 스트링 끝 요소 다음 요소를 가리키는 반복자가 반환된다.   rbegin, crbegin ~C++14~ 매개 변수 스트링의, 뒤에서 첫 요소를 가리키는 반복자가 반환된다.   rend, crend ~C++14~ 매개 변수 스트링의, 뒤에서 끝 요소 다음 요소를 가리키는 반복자가 반환된다.   size ~C++17~ ssize ~C++20~ 매개 변수 스트링의 크기가 바이트 수로 반환된다. ssize는 부호가 있는 크기(signed size)를 뜻한다.   empty ~C++17~ 매개 변수 스트링이 비어 있으면 true가 반환된다.   data ~C++17~ 매개 변수 스트링의 요소들(문자들)이 담겨 있는 메모리 블록의 주소가 반환된다.     반복자는 멤버 변수에 컨테이너·배열 요소 주소가 저장되는 객체이다. 포인터 변수를 다루듯이 역참조를 할 수 있지만(반복자를 역참조하면 현재 반복자가 가리키는 요소가 반환된다.) 반복자만의 멤버 함수가 있다는 점에서 반복자는 포인터 변수와 다르다. 스트링 변수에 저장한 문자열 리터럴을 문자열로 복사할 때 아래 예처럼 std::data를 쓸 수 있다.  1 2 3 4 5 6 7 8 9 10 11 12 13  #include \u0026lt;string\u0026gt;#include \u0026lt;cstring\u0026gt; // strcpy#include \u0026lt;iostream\u0026gt;using namespace std; int main() { string s {\u0026#34;Hello!\u0026#34;}; cout \u0026lt;\u0026lt; s; // 출력: Hello!  cout \u0026lt;\u0026lt; data(s); // 출력: Hello!  char cstr[10]; strcpy(cstr, data(s)); // data(s) 대신에 s나 \u0026amp;s가 올 수 없다. cstr = s;도 안 된다.  cout \u0026lt;\u0026lt; cstr; // 출력: Hello! }   요소 접근(연산자 제외)    멤버 함수 설명     at 특정 위치에 있는 문자를 가리키는 참조자가 반환된다. 참조자가 반환되므로 해당 위치 문자를 다른 문자로 변경할 수 있다. 용례: std::cout \u0026lt;\u0026lt; str.at(1); str.at(2) = 'B';   front ~C++11~ 스트링 첫 문자를 가리키는 참조자가 반환된다. s.front()는 s[0] 또는 s.at(0)과 동일한 기능을 한다.   back ~C++11~ 스트링 끝 문자를 가리키는 참조자가 반환된다. s.back()는 s[s.size() - 1] 또는 s.at(s.size() - 1)과 동일한 기능을 한다.   data 스트링의 요소들(문자들)이 담겨 있는 배열을 가리키는 포인터가 반환된다. 스트링 이름이 s일 때 문자들은 s.data()가 가리키는 곳부터 s.data() + s.size()가 가리키는 곳까지 담겨 있다. s.data() + s.size()가 가리키는 곳에 있는 문자는 널 문자이므로 *(s.data() + s.size())는 0과 같다.   c_str C+11부터 data와 동일한 기능을 하는 함수이다. 스트링 이름이 s일 때 *(s.c_str() + s.size())는 0과 같다.    반복자    멤버 함수 설명     begin, cbegin ~C++11~ 스트링의 첫 문자를 가리키는 반복자(iterator)가 반환된다. 스트링에 담긴 문자를 다른 문자로 변경하지 않으려면 cbegin을 쓰는 편이 좋다. C++17부터 std::as_const를 쓸 수 있으니 스트링 이름이 s일 때 std::as_const(s).begin()과 s.cbegin()은 동일한 기능을 한다고 볼 수 있다.   end, cend ~C++11~ 스트링의 끝 문자 다음 문자를 가리키는 반복자가 반환된다. 이름이 s인 스트링에 \u0026quot;abc\u0026quot;를 담았다면 *(s.end() - 1)은 c와 같다.   rbegin, crbegin ~C++11~ 스트링의, 뒤에서 첫 문자를 가리키는 반복자가 반환된다. 이름이 s인 스트링에 \u0026quot;abc\u0026quot;를 담았다면 *s.rbegin()은 c와 같다.   rend, crend ~C++11~ 스트링의, 뒤에서 끝 문자 다음 문자를 가리키는 반복자가 반환된다. 이름이 s인 스트링에 \u0026quot;abc\u0026quot;를 담았다면 *(s.rend() - 1)은 a와 같다.    용량    멤버 함수 설명     empty 스트링 변수가 비어 있으면 true가, 비어 있지 않으면 false가 반환된다. 스트링 변수 s가 비어 있으면 s.begin()과 s.end()가 같다.   size, length 스트링의 코드 유닛 수(CharT 요소 수)가 반환된다. size와 length는 동의어이다.   max_size 스트링 변수에 담을 수 있는 최대 문자 개수가 반환된다. s.max_size()처럼 쓴다.   capacity 스트링 변수에 현재 할당되어 있는 공간이 문자 개수로 반환된다.   shrink_to_fit 스트링 변수가 실제로 쓰지 않는 공간을 제거하려고 할 때 쓴다. 예를 들어 이름이 s인 스트링이 있으면 s.capacity()가 s.size()로 줄이려고 할 때 s.shrink_to_fit()을 쓴다.    연산(연산자 제외)    비멤버 함수\n(이름 공간: std) 설명     swap 스트링 내용을 서로 교환할 때 쓴다. swap(lhs, rhs)는 lhs.swap(rhs)와 동일한 기능을 한다.   erase, erase_if ~C++20~ 스트링에서 특정 조건을 만족하는 문자나 문자들을 삭제할 때 쓴다. 삭제된 문자 수가 반환된다.       멤버 함수 설명     swap 스트링 내용을 서로 교환할 때 쓴다. lhs.swap(rhs)는 swap(lhs, rhs)와 동일한 기능을 한다.   clear 스트링에 담긴 문자를 전부 제거할 때 쓴다. 이 함수를 쓰더라도 스트링 변수에 할당된 메모리 공간(capacity)이 줄지 않는다.   insert 스트링에 문자를(문자들을) 삽입할 때 쓴다.9   erase 스트링에서 문자를(문자들을) 제거할 때 쓴다. 인수에 숫자 리터럴을 쓸 수도 있지만 인수에 \u0026lt;algorithm\u0026gt;에 정의되어 있는 find 함수를 쓰거나 std::basic_string 멤버인 find 함수를 쓸 수도 있다.   push_back 스트링 끝에 문자 하나를 붙일 때 쓴다.   pop_back ~C++11~ 스트링 끝 문자 하나를 제거할 때 쓴다. 스트링 이름이 s라면 s.pop_back()은 s.erase(s.end() - 1)과 동일한 기능을 한다.   append 스트링 끝에 문자를 하나 이상 붙일 때 쓴다.10   compare 두 문자 시퀀스를 비교할 때 쓴다.11   starts_with ~C++20~ 첫 번째 인수로 주어진 스트링이 두 번째 인수로 주어진 스트링 뷰(string view), 또는 문자, 스트링으로 시작하는지 검사할 때 쓴다. 반환형은 bool이다.   ends_with ~C++20~ 첫 번째 인수로 주어진 스트링이 두 번째 인수로 주어진 스트링 뷰(string view), 또는 문자, 스트링으로 끝나는지 검사할 때 쓴다. 반환형은 bool이다.   contains ~C++23~ 첫 번째 인수로 주어진 스트링이 두 번째 인수로 주어진 스트링 뷰(string view), 또는 문자, 스트링을 포함하는지 검사할 때 쓴다. 반환형은 bool이다.   replace 인수들로 주어진 범위에 해당하는 스트링 부분을 다른 인수에 있는 문자나 문자들로 변경할 때 쓴다.   substr 인수로 주어진 위치부터 스트링 끝까지나 인수들로 주어진 범위에 해당하는 스트링 부분이 반환된다.   copy 스트링 부분을 다른 스트링에 복사하여 넣을 때 쓴다. 복사된 문자 개수가 반환된다.   resize 스트링이 담을 수 있는 문자 개수가 주어진 인수가 되도록 스트링 크기를 조절할 때 쓴다.    탐색    멤버 함수 설명     find 스트링에서 특정 문자나 특정 문자열이 있는 최초 위치를 찾을 때 쓴다. 스트링에 해당 문자·문자열이 있으면 그 문자·문자열이 있는 최초 위치가, 없으면 부호 있는 값으로 변환하였을 때 -1인 npos(즉 부호 없는 정수형 변수가 저장할 수 있는 최댓값)가 반환된다.   rfind 스트링에서 특정 문자나 특정 문자열이 있는 최종 위치를 찾을 때 쓴다.   find_first_of 스트링에서 특정 문자가 있거나 특정 문자열을 구성하는 문자가 하나라도 있는 최초 위치를 찾을 때 쓴다.   find_first_not_of 스트링에서 특정 문자가 없거나 특정 문자열을 구성하는 문자가 없는 최초 위치를 찾을 때 쓴다.   find_last_of 스트링에서 특정 문자가 있거나 특정 문자열을 구성하는 문자가 하나라도 있는 최종 위치를 찾을 때 쓴다.   find_last_not_of 스트링에서 특정 문자나 특정 문자열을 구성하는 문자가 없는 최종 위치를 찾을 때 쓴다.     참조 cppreference.com\nHow to use char, wchar_t, char16_t and char32_t right a way in C++\nProgramming with Unicode\nSimplify Your Code With Rocket Science: C++20’s Spaceship Operator\nData Type Ranges\n  스트링 리터럴 끝에 붙는 널 문자(null terminator)를 포함하였을 때 스트링 리터럴의 크기는 n 코드 유닛이다. 스트링 리터럴 자료형을 보면 C 언어처럼 문자열(character array)로 스트링이 저장됨을 알 수 있다. \u0026#x21a9;\u0026#xfe0e;\n 어떤 컴파일러(compiler)에서는 UTF-8이 쓰일 터이고 다른 컴파일러에서는 다른 부호화 형식이 쓰일 터이다. \u0026#x21a9;\u0026#xfe0e;\n 윈도즈(Windows /ˈwɪndoʊz/) 사용자는 UTF-16을 가리키는 데에 유니코드(Unicode)라는 용어를 쓰기도 한다. 그러나 유니코드(Unicode)는 문자 부호화·표시·처리 목적으로 Unicode Consortium이 관리하는 IT(정보 기술) 표준이며 UTF는 Unicode Transformation Format(유니코드 변환 형식)의 두문자어다. \u0026#x21a9;\u0026#xfe0e;\n 윈도즈 컴파일러에서는 16-bit 부호화 형식(윈도즈 Me까지 UCS-2, 윈도즈 2000부터 UTF-16), 리눅스(Linux /ˈlɪnʊks/) 컴파일러에서는 32-bit 부호화 형식(UCS-4)이 쓰이는 편이라고 한다. UCS-4는 UTF-32와 같다고 볼 수 있지만, UCS-2는 UTF-16과는 다르게 surrogate pairs 사용을 지원하지 않는다. Surrogate pair 하나(총 4 bytes)는 다국어 기본 평면(basic multilingual plane, BMP)을 벗어나는 문자 하나를 표현한다. \u0026#x21a9;\u0026#xfe0e;\n != 연산자 정의는 C++20에 기본으로 존재하지 않는다. 그렇지만 이 말은 코드에 a != b 같은 내용을 적으면 안 된다는 말도 아니고 != 연산자를 프로그래머가 정의할 수 없다는 말도 아니다. != 연산자 정의가 따로 없으면 a != b가 !(a == b)로 해석될 뿐이다. \u0026#x21a9;\u0026#xfe0e;\n \u0026lt;=\u0026gt;는 우주선 연산자(spaceship operator)로 불린다. C++20 std::strong_ordering 클래스 또는 동종 클래스에 있는 정적 공용 멤버 상수(public static member constant)가 정수 리터럴 0과 비교될 수 있다. 이 상수(less, greater, equivalent 등)와 정수 리터럴 0를 비교하는 연산(==, \u0026lt;, \u0026gt;, \u0026lt;=, \u0026gt;= 연산자를 썼을 때에만)에서 true나 false가 반환된다. 이 둘을 대상으로 하지 않는 \u0026lt;, \u0026gt;, \u0026lt;=, \u0026gt;= 연산자(크기 비교 연산자)의 정의는 C++20에 기본으로 존재하지 않는다. \u0026#x21a9;\u0026#xfe0e;\n 예를 들어 std:string s = \u0026quot;a\\0b\u0026quot;;와 std:string s = \u0026quot;a\\0b\u0026quot;s;는 다르다. 전자를 쓰면 s.size()가 1을 반환하며 s를 출력하였을 때 a만 나오지만, 후자를 쓰면 s.size()가 3을 반환하고 s를 출력하였을 때 ab가 나온다. \u0026#x21a9;\u0026#xfe0e;\n using namespace std::literals나 using namespace std::string_literals, 아니면 using namespace std::literals::string_literals을 쓰면 된다. \u0026#x21a9;\u0026#xfe0e;\n 매개 변수 조합이 다양하므로 용례를 참고할 필요가 있다. \u0026#x21a9;\u0026#xfe0e;\n 인수로 쓸 수 있는 것들이 많으므로 용례를 참고할 필요가 있다. \u0026#x21a9;\u0026#xfe0e;\n 용례를 참고할 필요가 있다. \u0026#x21a9;\u0026#xfe0e;\n   ","date":"2020-11-22","permalink":"https://git-kim.github.io/posts/c++-%EC%8A%A4%ED%8A%B8%EB%A7%81string/","tags":null,"title":"C++ 스트링(string)"}]