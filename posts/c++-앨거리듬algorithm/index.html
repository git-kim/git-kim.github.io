<!DOCTYPE html>
<html lang="en-us">
    <head>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<title>C&#43;&#43; 앨거리듬(algorithm) &mdash;T. K.</title>
		<link rel="stylesheet" href="/css/bigfoot-number.min.51de71470813d1d605ba1d09d5d829f200cd1f2ca434b63e4a8b61acf1c10d6c.css" integrity="sha256-Ud5xRwgT0dYFuh0J1dgp8gDNHyykNLY&#43;SothrPHBDWw=" crossorigin="anonymous"><link rel="stylesheet" href="/css/bigfoot-custom.min.e62675dc71a51b942c5fd7fa196dd6aeba76926e226bac781450b893bf1b75a6.css" integrity="sha256-5iZ13HGlG5QsX9f6GW3Wrrp2km4ia6x4FFC4k78bdaY=" crossorigin="anonymous">
  		<link rel="stylesheet" href="/css/style.css">
		<link rel="stylesheet" href="/css/fonts.css">
		<link rel="stylesheet" href="/css/custom.min.5978f60b71bfe7298d776d6591fa9edd50ba4f12a17c23ab386b428b1efbf4f4.css" integrity="sha256-WXj2C3G/5ymNd21lkfqe3VC6TxKhfCOrOGtCix779PQ=" crossorigin="anonymous">

		
		<link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
		<link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
		<link rel="icon" type="image/png" sizes="192x192" href="/images/android-chrome-192x192.png">
		<link rel="icon" type="image/png" sizes="256x256" href="/images/android-chrome-256x256.png">
		<link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

		
		<link href="" rel="alternate" type="application/rss+xml" title="T. K." />
		
		<script src="/js/common.min.cc5821c13656c6a218ca2eda47234830ce794fe108cc0567ea39d55486356794.js" integrity="sha256-zFghwTZWxqIYyi7aRyNIMM55T&#43;EIzAVn6jnVVIY1Z5Q=" crossorigin="anonymous"></script>
	</head>

    <body>
        		<nav class="nav">
			<div class="nav-container">
				<a href="/">
					<h2 class="nav-title">T. K.</h2>
				</a>
				<ul>
    <li>
            <a href="/posts/">
                
                <span>Posts</span>
                
            </a>
        </li><li>
            <a href="/categories/">
                
                <span>Categories</span>
                
            </a>
        </li><li>
            <a href="/search/">
                
                <span>Search</span>
                
            </a>
        </li><li><div class="theme-switch"></div></li>
</ul>
			</div>
		</nav>

        

<main>
	<div class="post">
		<div class="post-info">
    <span>Written by</span>
        T. Kim
        <br>
        <span>on&nbsp;</span><time datetime="2020-11-23 22:00:03 &#43;0900 KST">November 23, 2020</time>
</div>

		<h1 class="post-title">C&#43;&#43; 앨거리듬(algorithm)</h1>
<div class="post-line"></div>

		<h3 id="헤더-algorithm">헤더: <code>&lt;algorithm&gt;</code></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span></code></pre></td></tr></table>
</div>
</div><h3 id="주요-함수c20-niebloid-제외">주요 함수(<code>C++20</code> niebloid 제외)</h3>
<h4 id="불변경non-modifying-시퀀스-연산">불변경(non-modifying) 시퀀스 연산</h4>
<table>
<thead>
<tr>
<th>함수</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>all of</code>, <code>any of</code>, <code>none of</code> <sub>C++11</sub></td>
<td>매개 변수는 (실행 정책 <sub>C++17</sub>,)  범위 처음을 가리키는 반복자, 범위 끝의 바로 다음을 가리키는 반복자, unary predicate(매개 변수 하나가 쓰여 true나 false가 반환되는 함수)이다. 각각 범위 내 모든 요소를 대상으로 true가 나오는지, 범위 내 한 요소 이상을 대상으로 true가 나오는지, 범위 내 모든 요소를 대상으로 false가 나오는지 여부가 true, false로 반환된다.</td>
</tr>
<tr>
<td><code>for_each</code></td>
<td>매개 변수는 (실행 정책 <sub>C++17</sub>,) 범위 처음을 가리키는 반복자, 범위 끝의 바로 다음을 가리키는 반복자, unary function(매개 변수가 하나 쓰이는 함수)이다. 반복자를 역참조하였을 때 나오는 요소가 unary function의 매개 변수로 쓰여야 한다. 어떤 함수를 범위 내 요소들에 적용할 때 쓴다.</td>
</tr>
<tr>
<td><code>for_each_n</code> <sub>C++17</sub></td>
<td>매개 변수는 (실행 정책 <sub>C++17</sub>,) 반복자, 반복자가 가리키는 요소를 포함하여 함수를 적용할 요소 수, unary function(매개 변수가 하나 쓰이는 함수)이다. 어떤 함수를 어떤 요소부터 몇 요소에만 적용할 때 쓴다.</td>
</tr>
<tr>
<td><code>count</code>, <code>count_if</code></td>
<td>매개 변수는 (실행 정책 <sub>C++17</sub>,) 범위 처음을 가리키는 반복자, 범위 끝의 바로 다음을 가리키는 반복자, 그리고 <code>count</code>면 값, <code>count_if</code>면 unary predicate이다. 마지막 매개 변수에 맞는(값이면 일치하는, unary predicate면 반환 값이 true인) 요소들 수가 반환된다.</td>
</tr>
<tr>
<td><code>mismatch</code></td>
<td>매개 변수는 (실행 정책 <sub>C++17</sub>,) 범위 1 처음을 가리키는 반복자, 범위 1 끝의 바로 다음을 가리키는 반복자, 범위 2 처음을 가리키는 반복자(, 범위 2 끝의 바로 다음을 가리키는 반복자)(, binary predicate)이다. 지정한 범위에서 처음으로 일치하지 않는 두 요소의 위치를 가리키는 반복자들이 <code>std::pair</code>로 묶여 반환된다.</td>
</tr>
<tr>
<td><code>find</code>, <code>find_if</code><br /><code>find_if_not</code> <sub>C++11</sub></td>
<td>매개 변수는 (실행 정책 <sub>C++17</sub>,) 범위 처음을 가리키는 반복자, 범위 끝의 바로 다음을 가리키는 반복자, 그리고 <code>find</code>면 값, <code>find_if</code>나 <code>find_if_not</code>이면 unary predicate이다. 마지막 매개 변수에 맞는(값이면 일치하는, unary predicate면 반환 값이 각각 true, false인) 요소를 가리키는 반복자가 반환된다.</td>
</tr>
<tr>
<td><code>find_end</code></td>
<td>매개 변수는 (실행 정책 <sub>C++17</sub>,) 범위 1 처음을 가리키는 반복자, 범위 1 끝의 바로 다음을 가리키는 반복자, 범위 2 처음을 가리키는 반복자, 범위 2 끝의 바로 다음을 가리키는 반복자(, binary predicate)이다. 범위 2 시퀀스가 범위 1에서 마지막으로 나타나는 위치를 찾을 때 쓴다. 범위 2가 비어 있거나 범위 2 시퀀스가 범위 1에 존재하지 않을 때에는 범위 1 끝의 바로 다음을 가리키는 반복자가 반환되며, 범위 2 시퀀스가 범위 1에 존재할 때에는 마지막으로 그 시퀀스가 나타나는 위치(첫 요소 기준)를 가리키는 반복자가 반환된다.</td>
</tr>
<tr>
<td><code>find_first_of</code></td>
<td>매개 변수는 (실행 정책 <sub>C++17</sub>,) 범위 1 처음을 가리키는 반복자, 범위 1 끝의 바로 다음을 가리키는 반복자, 범위 2 처음을 가리키는 반복자, 범위 2 끝의 바로 다음을 가리키는 반복자(, binary predicate)이다. Binary predicate를 지정하지 않았을 때에는 범위 1에서 범위 2 요소와 같은 요소가 발견되면 그 위치(범위 1 대상)를 가리키는 반복자가 반환된다. <code>int</code> 요소에 쓸 수 있는 binary predicate의 예로 <code>std::less&lt;int&gt;()</code>가 있으며 이 함수를 쓰면 범위 1에서 범위 2 요소보다 작은 요소가 발견되었을 때 그 위치(범위 1 대상)를 가리키는 반복자가 반환된다.</td>
</tr>
<tr>
<td><code>adjacent_find</code></td>
<td>매개 변수는 (실행 정책 <sub>C++17</sub>,) 범위 처음을 가리키는 반복자, 범위 끝의 바로 다음을 가리키는 반복자(, binary predicate)이다. Binary predicate를 지정하지 않았을 때에는 같은 요소가 연달아 존재하는 위치(둘 중 첫 요소)를 가리키는 반복자가 반환된다. <code>int</code> 요소에 쓸 수 있는 binary predicate의 예로 <code>std::greater&lt;int&gt;()</code>가 있으며 이 함수를 쓰면 인접 요소끼리 비교되어 둘 중 작은 수가 뒤에 있는 쌍의 위치(둘 중 첫 요소)를 가리키는 반복자가 반환된다.</td>
</tr>
<tr>
<td><code>search</code></td>
<td>매개 변수는 (실행 정책 <sub>C++17</sub>,) 범위 1 처음을 가리키는 반복자, 범위 1 끝의 바로 다음을 가리키는 반복자, 범위 2 처음을 가리키는 반복자, 범위 2 끝의 바로 다음을 가리키는 반복자(, binary predicate)이다. 다만 범위 2 반복자들을 searcher(<code>boyer_moore_searcher</code> <sub>C++17</sub>, <code> boyer_moore_horspool_searcher</code> <sub>C++17</sub> 등)에 써서 그 searcher를 세 번째 인수로 지정할 수도 있다(<sub>C++17</sub>). 범위 2로 지정한 요소 시퀀스가 범위 1에 존재하면 그 위치(범위 1 대상)를 가리키는 반복자가 반환된다.</td>
</tr>
<tr>
<td><code>search_n</code></td>
<td>매개 변수는 (실행 정책 <sub>C++17</sub>,) 범위 처음을 가리키는 반복자, 범위 끝의 바로 다음을 가리키는 반복자, 개수, 값(, binary predicate)이다. Binary predicate를 지정하지 않았을 때에는 범위 내에서 지정한 개수만큼 지정한 값이 연달아 존재하는 위치를 가리키는 반복자가 반환된다. Binary predicate를 지정하였을 때에는 지정한 값과 범위 내 각 요소 값이 그 함수로 비교되어 그 함수에서 <code>true</code>가 지정한 개수만큼 연달아 반환되는 위치를 가리키는 반복자가 반환된다.</td>
</tr>
</tbody>
</table>
<h4 id="변경modifying-시퀀스-연산">변경(modifying) 시퀀스 연산</h4>
<table>
<thead>
<tr>
<th>함수</th>
<th>설명<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>copy</code></td>
<td>'지정 범위' 안에 있는 요소를 복사하여 '지정 위치'부터 넣기</td>
</tr>
<tr>
<td><code>copy_n</code> <sub>C++11</sub></td>
<td>'지정 범위' 안에 있는 요소를 복사하여 '지정 위치'부터 넣기</td>
</tr>
<tr>
<td><code>copy_if</code> <sub>C++11</sub></td>
<td>'지정 범위' 안에 있으면서 '지정 기준'을 충족하는 요소를 복사하여 '지정 위치'부터 넣기(참고: JavaScript <code>filter</code>와 유사하다.)</td>
</tr>
<tr>
<td><code>copy_backward</code></td>
<td>'지정 범위' 안에 있는 요소를 복사하여 '지정 위치' 바로 전까지 채워지도록 넣기(주의: 요소 순서는 <strong>변하지 않는다</strong>.)</td>
</tr>
<tr>
<td><code>move</code> <sub>C++11</sub></td>
<td>'지정 범위' 안에 있는 요소를 이동하여 '지정 위치'부터 넣기(참고: 원 요소가 있던 공간이 비게 된다.)</td>
</tr>
<tr>
<td><code>move_backward</code> <sub>C+11</sub></td>
<td>'지정 범위' 안에 있는 요소를 이동하여 '지정 위치' 바로 전까지 채워지도록 넣기(주의: 요소 순서는 <strong>변하지 않는다</strong>. 참고: 원 요소가 있던 공간이 비게 된다.)</td>
</tr>
<tr>
<td><code>fill</code></td>
<td>'지정 값'을 '지정 범위' 안에 복사 대입(copy assignment) 하기</td>
</tr>
<tr>
<td><code>fill_n</code></td>
<td>'지정 값'을 '지정 범위' 안에 복사 대입 하기</td>
</tr>
<tr>
<td><code>transform</code></td>
<td>'지정 범위'(와 '지정 위치'로 시작하는 범위) 안에 있는 요소를 대상으로 '지정 함수'를 호출하여 그 함수에서 반환되는 값을 '지정 위치'부터 넣기(참고: JavaScript <code>map</code>과 유사하다.)</td>
</tr>
<tr>
<td><code>generate</code></td>
<td>'지정 함수'를 거듭 호출하면서 그 함수에서 반환되는 값을 '지정 범위' 안에 순차로 대입하기(예를 들어 <code>std::generate(v.begin(), v.end(), [n = 0] () mutable { return n++; });</code>은 <code>std::iota(v.begin(), v.end(), 0);</code>과 동일한 기능을 한다. 참고: <code>mutable</code>이 있어야 램더 식(lambda expression)에서 변수 값을 변경할 수 있다.)</td>
</tr>
<tr>
<td><code>generate_n</code></td>
<td>'지정 함수'를 거듭 호출하면서 그 함수에서 반환되는 값을 '지정 범위' 안에 순차로 대입하기</td>
</tr>
<tr>
<td><code>remove</code></td>
<td>'지정 범위' 안에 있으면서 '지정 값'과 같은 요소를 제거하기</td>
</tr>
<tr>
<td><code>remove_if</code></td>
<td>'지정 범위' 안에 있으면서 '지정 기준'을 충족하는 요소를 제거하기</td>
</tr>
<tr>
<td><code>remove_copy</code></td>
<td>'지정 범위' 안에 있는 요소를 복사하여 '지정 위치'부터 넣되 '지정 값'과 같은 요소를 제거하기</td>
</tr>
<tr>
<td><code>remove_copy_if</code></td>
<td>'지정 범위' 안에 있는 요소를 복사하여 '지정 위치'부터 넣되 '지정 기준'을 충족하는 요소를 제거하기</td>
</tr>
<tr>
<td><code>replace</code></td>
<td>'지정 값'과 같은 요소를 전부 동일한 '지정 값'으로 변경하기</td>
</tr>
<tr>
<td><code>replace_if</code></td>
<td>'지정 기준'을 충족하는 요소를 전부 동일한 '지정 값'으로 변경하기</td>
</tr>
<tr>
<td><code>replace_copy</code></td>
<td>'지정 범위' 안에 있는 요소를 복사하여 '지정 위치'부터 넣되 '지정 값'과 같은 요소를 전부 동일한 '지정 값'으로 변경하기</td>
</tr>
<tr>
<td><code>replace_copy_if</code></td>
<td>'지정 범위' 안에 있는 요소를 복사하여 '지정 위치'부터 넣되 '지정 기준'을 충족하는 요소를 전부 동일한 '지정 값'으로 변경하기</td>
</tr>
<tr>
<td><code>swap</code></td>
<td>'지정 값'과 '지정 값'을 교환하기</td>
</tr>
<tr>
<td><code>swap_ranges</code></td>
<td>'지정 범위' 안에 있는 요소와 '지정 위치'부터 있는 요소를 교환하기</td>
</tr>
<tr>
<td><code>iter_swap</code></td>
<td>'지정 위치'에 있는 요소와 '지정 위치'에 있는 요소를 교환하기(참고: <code>std::min_element</code>를 함께 써서 선택 정렬을 하는 데에 쓸 수 있다.)</td>
</tr>
<tr>
<td><code>reverse</code></td>
<td>'지정 범위' 안에 있는 요소의 순서를 뒤집기</td>
</tr>
<tr>
<td><code>reverse_copy</code></td>
<td>'지정 범위' 안에 있는 요소를 복사하여 '지정 위치'부터 넣되 요소 순서를 뒤집기(참고: 범위를 지정할 때 <code>rbegin</code>과 <code>rend</code>를 쓰면 요소 순서가 본래 순서와 같게 된다.)</td>
</tr>
<tr>
<td><code>rotate</code></td>
<td>'지정 위치'에 있는 요소를 축으로 '지정 범위' 안에 있는 요소를 두 집단으로 보아 집단을 교환하기(참고: <code>std::upper_bound</code>를 함께 써서 삽입 정렬을 하는 데에 쓸 수 있다.)</td>
</tr>
<tr>
<td><code>rotate_copy</code></td>
<td>'지정 범위' 안에 있는 요소를 복사하여 '지정 위치'부터 넣되 '지정 위치'에 있는 요소를 축으로 '지정 범위' 안에 있는 요소를 두 집단으로 보아 집단을 교환하기</td>
</tr>
<tr>
<td><code>shift_left</code>, <code>shift_right</code> <sub>C++20</sub></td>
<td>'지정 범위' 안에 있는 요소 위치를 '지정 숫자'만큼 이동하기(참고: '지정 범위'를 벗어나는 요소는 제거된다.)</td>
</tr>
<tr>
<td><code>random_shuffle</code> <sub>deprecated</sub> <sub>in</sub> <sub>C++14</sub> <br /><code>shuffle</code> <sub>C++11</sub></td>
<td>'지정 범위' 안에 있는 요소를 무작위 순서로 다시 나열하기(이제는 무작위 수 생성기를 지정하여야 한다.)</td>
</tr>
<tr>
<td><code>sample</code> <sub>C++17</sub></td>
<td>'지정 범위'에서 무작위로 요소를 '지정 개수'만큼 추출하여 '지정 위치'부터 넣기(무작위 수 생성기를 지정하여야 한다.)</td>
</tr>
<tr>
<td><code>unique</code></td>
<td>'지정 범위'에 연속으로 동일한 요소가 있으면 동일한 요소를 하나만 남기기(참고: 두 요소를 같다고 볼 '기준'을 지정할 수도 있다.)</td>
</tr>
<tr>
<td><code>unique_copy</code></td>
<td>'지정 범위' 안에 있는 요소를 복사하여 '지정 위치'부터 넣되 '지정 범위'에 연속으로 동일한 요소가 있으면 동일한 요소를 하나만 남기기(참고: 두 요소를 같다고 볼 '기준'을 지정할 수도 있다.)</td>
</tr>
</tbody>
</table>
<h4 id="분할partitioning-연산">분할(partitioning) 연산</h4>
<table>
<thead>
<tr>
<th>함수</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>is_partitioned</code> <sub>C++11</sub></td>
<td>'지정 기준'을 충족하는 요소들이 전부 '지정 범위' 앞부분에 있고 충족하지 않는 요소들이 뒷부분에 있는지 확인하기<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup></td>
</tr>
<tr>
<td><code>partition</code></td>
<td>'지정 기준'을 충족하는 요소들을 전부 '지정 범위' 앞부분에 있게 하기</td>
</tr>
<tr>
<td><code>partition_copy</code> <sub>C++11</sub></td>
<td>'지정 범위' 안에 있는 요소를 복사하여 '지정 기준'을 충족하는 요소들을 전부 '지정 위치'부터 넣고, 충족하지 않는 요소들을 다른 '지정 위치'부터 넣기</td>
</tr>
<tr>
<td><code>stable_partition</code></td>
<td>'지정 기준'을 충족하는 요소들을 전부 '지정 범위' 앞부분에 있게 하되 요소 간 상대 순서를 유지하기<sup id="fnref:3"><a href="#fn:3" class="footnote-ref" role="doc-noteref">3</a></sup></td>
</tr>
<tr>
<td><code>partition_point</code> <sub>C++11</sub></td>
<td>'지정 기준'을 충족하는 마지막 요소의 바로 다음 요소 위치를 알아내기</td>
</tr>
</tbody>
</table>
<h4 id="정렬sorting-연산">정렬(sorting) 연산</h4>
<table>
<thead>
<tr>
<th>함수</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>is_sorted</code> <sub>C++11</sub></td>
<td>'지정 범위' 안에 있는 요소들이 값이 작아지지 않는 순서로 있는지 검사하기(추가로 비교 '기준'을 지정하여 줄 수도 있다.)</td>
</tr>
<tr>
<td><code>is_sorted_until</code> <sub>C++11</sub></td>
<td>'지정 범위' 안에서 바로 앞 요소보다 값이 작은 첫 요소의 위치를 알아내기(반복자가 반환된다. 추가로 비교 '기준'을 지정하여 줄 수도 있다.)</td>
</tr>
<tr>
<td><code>sort</code></td>
<td>'지정 범위' 안에 있는 요소들을 값이 작아지지 않는 순서로 있도록 정렬하기(추가로 비교 '기준'을 지정하여 줄 수도 있다. 예를 들어 <code>std::greater&lt;int&gt;()</code>을 지정하면 <code>int</code> 요소들을 값이 커지지 않는 순서로 있도록 정렬할 수 있다.)<sup id="fnref:4"><a href="#fn:4" class="footnote-ref" role="doc-noteref">4</a></sup></td>
</tr>
<tr>
<td><code>partial_sort</code></td>
<td>첫 '지정 위치'부터 세 번째 '지정 위치' 직전까지 범위 안에 있는 요소 중에서 작은 값이 있는 요소가 첫 '지정 위치'부터 두 번째 '지정 위치' 직전까지 범위 안에 값이 작아지지 않는 순서로 있게 하기(요소 간 상대 순서는 보존되지 않는다. 추가로 비교 '기준'을 지정하여 줄 수도 있다.)<sup id="fnref:5"><a href="#fn:5" class="footnote-ref" role="doc-noteref">5</a></sup></td>
</tr>
<tr>
<td><code>partial_sort_copy</code></td>
<td>'지정 범위'에 있는 요소들을 복사하여 다른 '지정 범위'에 넣고 그 요소들만 정렬하기(범위 크기가 다르면 작은 쪽에 맞춘다. 추가로 비교 '기준'을 지정하여 줄 수도 있다.)</td>
</tr>
<tr>
<td><code>stable_sort</code></td>
<td>'지정 범위' 안에 있는 요소들을 값이 작아지지 않는 순서로 있도록 정렬하되 요소 간 상대 순서를 유지하기(추가로 비교 '기준'을 지정하여 줄 수도 있다.)<sup id="fnref:6"><a href="#fn:6" class="footnote-ref" role="doc-noteref">6</a></sup></td>
</tr>
<tr>
<td><code>nth_element</code></td>
<td>'지정 범위' 안에 있는 요소들을 비교하여 '지정 위치'에 있어야 할 요소보다 값이 작은 요소는 그 요소 앞에, 같거나 큰 요소는 뒤에 오도록 요소들을 '지정 위치'를 기준으로 분리하기(요소가 전부 정렬되지는 않는다. 분할 연산이라 볼 수도 있겠다. 추가로 비교 '기준'을 지정하여 줄 수도 있다. 중간값이나 n 번째로 작거나 큰 값을 구할 때 유용하다.)</td>
</tr>
</tbody>
</table>
<h4 id="이진-탐색binary-search-연산-정렬된-범위에-사용한다">이진 탐색(binary search) 연산 (정렬된 범위에 사용한다.)</h4>
<table>
<thead>
<tr>
<th>함수</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>lower_bound</code></td>
<td>'지정 범위' 안에서 값이 '지정 값'과 같거나 그 값보다 <strong>큰</strong> 요소의 위치를 알아내기(추가로 비교 '기준'을 지정하여 줄 수도 있다. 주의: 수학에서 말하는 하계와는 다르다.)</td>
</tr>
<tr>
<td><code>upper_bound</code></td>
<td>'지정 범위' 안에서 값이 '지정 값'보다 큰 요소의 위치를 알아내기(추가로 비교 '기준'을 지정하여 줄 수도 있다. 주의: 수학에서 말하는 상계와는 다르다.)</td>
</tr>
<tr>
<td><code>binary_search</code></td>
<td>'지정 범위' 안에 있는 요소 중에 값이 '지정 값'과 같은 요소가 있는지 확인하기(추가로 비교 '기준'을 지정하여 줄 수도 있다.)</td>
</tr>
<tr>
<td><code>equal_range</code></td>
<td>'지정 범위'와 '지정 값'에 맞는 <code>lower_bound</code>와 <code>upper_bound</code>를 <code>pair</code>로 반환시키기(추가로 비교 '기준'을 지정하여 줄 수도 있다.)</td>
</tr>
</tbody>
</table>
<h4 id="집합set-연산-정렬된-범위에-사용한다">집합(set) 연산 (정렬된 범위에 사용한다.)</h4>
<table>
<thead>
<tr>
<th>함수</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>includes</code></td>
<td>두 번째 '지정 범위' 안에 있는 요소들이 첫 번째 '지정 범위' 안에 있는 요소들로 구성되는 부분열(<a href="https://en.wikipedia.org/wiki/subsequence" target="_blank" rel="noopener">subsequence</a>)인지 검사하기(추가로 비교 '기준'을 지정하여 줄 수도 있다. 예를 들어 <code>{'a', 'c'}</code>는 <code>{'a', 'b', 'c'}</code>의 부분열이지만 <code>{'c', 'a'}</code>는 아니기 때문에 이 함수를 사용하기 전에 정렬을 하여야 한다.)</td>
</tr>
<tr>
<td><code>set_difference</code></td>
<td>두 '지정 범위' 집합의 <strong>차집합</strong>을 '지정 위치'에 만들기(추가로 비교 '기준'을 지정하여 줄 수도 있다.)</td>
</tr>
<tr>
<td><code>set_intersection</code></td>
<td>두 '지정 범위' 집합의 <strong>교집합</strong>을 '지정 위치'에 만들기(추가로 비교 '기준'을 지정하여 줄 수도 있다.)</td>
</tr>
<tr>
<td><code>set_symmetric_difference</code></td>
<td>두 '지정 범위' 집합의 <strong>대칭 차집합</strong>을 '지정 위치'에 만들기(추가로 비교 '기준'을 지정하여 줄 수도 있다.)</td>
</tr>
<tr>
<td><code>set_union</code></td>
<td>두 '지정 범위' 집합의 <strong>합집합</strong>을 '지정 위치'에 만들기(추가로 비교 '기준'을 지정하여 줄 수도 있다.)</td>
</tr>
</tbody>
</table>
<h4 id="정렬된-범위에-사용하는-다른-연산">정렬된 범위에 사용하는 다른 연산</h4>
<table>
<thead>
<tr>
<th>함수</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>merge</code></td>
<td>두 정렬된 '지정 범위'를 병합하되 값이 작아지지 않는 순서로 요소들이 있도록 '지정 위치'에 만들기(추가로 비교 '기준'을 지정하여 줄 수도 있다.)</td>
</tr>
<tr>
<td><code>inplace_merge</code></td>
<td>첫 두 '지정 위치'에 해당하는 범위와 두 번째 '지정 위치', 세 번째 '지정 위치'에 해당하는 범위를 병합하되 값이 작아지지 않는 순서로 요소들이 있게 하기(추가로 비교 '기준'을 지정하여 줄 수도 있다. 참고: 이 함수를 사용하여 merge sort를 구현할 수 있다.)</td>
</tr>
</tbody>
</table>
<h4 id="히프heap-연산">히프(heap) 연산</h4>
<table>
<thead>
<tr>
<th>함수</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>is_heap</code> <sub>C++11</sub></td>
<td>'지정 범위' 안에 있는 요소들이 최대 히프(부모 노드 값이 자식 노드 값보다 크거나 자식 노드 값과 같은 이진 트리)를 이루는지 검사하기(추가로 비교 '기준'을 지정하여 줄 수도 있다.)</td>
</tr>
<tr>
<td><code>is_heap_until</code> <sub>C++11</sub></td>
<td>'지정 범위' 안에서 최대 히프가 끝나는 바로 다음 '위치'를 알아내기(추가로 비교 '기준'을 지정하여 줄 수도 있다.)</td>
</tr>
<tr>
<td><code>make_heap</code></td>
<td>'지정 범위' 안에 있는 요소들이 최대 히프를 이루게 하기(추가로 비교 '기준'을 지정하여 줄 수도 있다. 예를 들어 <code>std::greater&lt;&gt;{}</code>가 비교 기준이면 요소들은 최소 히프를 이루게 된다.)</td>
</tr>
<tr>
<td><code>push_heap</code></td>
<td>'지정 범위' 안에서 마지막 요소를 제외하고 최대 히프를 이루고 있을 때 그 요소 포함하여 최대 히프를 이루게 하기(추가로 비교 '기준'을 지정하여 줄 수도 있다.)</td>
</tr>
<tr>
<td><code>pop_heap</code></td>
<td>'지정 범위' 안에서 최대 히프 최상위 노드에 해당하는 요소를 마지막 요소와 교환한 후 마지막 요소를 제외하고 나머지 요소들이 최대 히프를 이루게 하기(추가로 비교 '기준'을 지정하여 줄 수도 있다.)</td>
</tr>
<tr>
<td><code>sort_heap</code></td>
<td>'지정 범위' 최대 히프를 오름차순으로 정렬된 요소들이 있는 범위로 변환하기(추가로 비교 '기준'을 지정하여 줄 수도 있다.)</td>
</tr>
</tbody>
</table>
<h4 id="최대최소-연산">최대·최소 연산</h4>
<table>
<thead>
<tr>
<th>함수</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>max</code></td>
<td>두 값 중 큰 값 찾기 또는 초기화 목록에서 가장 큰 값 찾기(추가로 비교 '기준'을 지정하여 줄 수도 있다.)</td>
</tr>
<tr>
<td><code>max_element</code></td>
<td>'지정 범위'에서 가장 큰 값이 있는 요소의 위치를 찾기(추가로 비교 '기준'을 지정하여 줄 수도 있다.)</td>
</tr>
<tr>
<td><code>min</code></td>
<td>두 값 중 작은 값 찾기 또는 초기화 목록에서 가장 작은 값 찾기(추가로 비교 '기준'을 지정하여 줄 수도 있다.)</td>
</tr>
<tr>
<td><code>min_element</code></td>
<td>'지정 범위'에서 가장 작은 값이 있는 요소의 위치를 찾기(추가로 비교 '기준'을 지정하여 줄 수도 있다.)</td>
</tr>
<tr>
<td><code>minmax</code> <sub>C++11</sub></td>
<td>두 값 중 작은 값과 큰 값을 <code>pair</code>로 반환시키기 또는 초기화 목록에서 가장 작은 값과 가장 큰 값을 <code>pair</code>로 반환시키기(추가로 비교 '기준'을 지정하여 줄 수도 있다.)</td>
</tr>
<tr>
<td><code>minmax_element</code> <sub>C++11</sub></td>
<td>'지정 범위'에서 가장 작은 값이 있는 요소의 위치와 가장 큰 값이 있는 요소의 위치를 <code>pair</code>로 반환시키기(추가로 비교 '기준'을 지정하여 줄 수도 있다.)</td>
</tr>
<tr>
<td><code>clamp</code> <sub>C++17</sub></td>
<td>첫 '지정 값'이 두 번째 '지정 값'보다 작으면 두 번째 '지정 값'을, 세 번째 '지정 값'보다 크면 세 번째 '지정 값'을, 아니면 첫 '지정 값'을 반환시키기(어떤 변숫값의 한계를 지정할 때 유용하다. 추가로 비교 '기준'을 지정하여 줄 수도 있다.)</td>
</tr>
</tbody>
</table>
<h4 id="비교-연산">비교 연산</h4>
<table>
<thead>
<tr>
<th>함수</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>equal</code></td>
<td>두 '지정 범위' 요소들이 같은지 확인하기(두 범위는 세 반복자나 네 반복자를 사용하여 지정한다. 회문(palindrome)을 찾을 때 유용하다. 추가로 비교 '기준'을 지정하여 줄 수도 있다.)</td>
</tr>
<tr>
<td><code>lexicographical_compare</code> <sub>C++20</sub></td>
<td>사전식으로 비교하여 첫 '지정 범위'가 두 번째 '지정 범위'보다 작은지 확인하기(각 범위는 두 반복자를 사용하여 지정한다. 추가로 비교 '기준'을 지정하여 줄 수도 있다.)</td>
</tr>
<tr>
<td><code>lexicographical_compare_three_way</code> <sub>C++20</sub></td>
<td>두 '지정 범위'를 사전식으로 비교하여 정수 리터럴 <code>0</code>과 비교될 수 있는 값 하나(<code>std::strong_ordering::greater</code>, <code>std::strong_ordering::less</code>, <code>std::strong_ordering::equal</code> 중 하나)를 반환시키기(추가로 비교 '기준'을 지정하여 줄 수도 있다.)<sup id="fnref:7"><a href="#fn:7" class="footnote-ref" role="doc-noteref">7</a></sup></td>
</tr>
</tbody>
</table>
<h4 id="순열permutation-연산">순열(permutation) 연산</h4>
<table>
<thead>
<tr>
<th>함수</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>is_permutation</code> <sub>C++11</sub></td>
<td>'지정 범위' 안에 있는 요소들로 '지정 위치' 요소부터 시작하는 시퀀스(또는 다른 '지정 범위' 안의 요소들이 이루는 시퀀스)를 만들 수 있는지 확인하기(추가로 비교 '기준'을 지정하여 줄 수도 있다.)</td>
</tr>
<tr>
<td><code>next_permutation</code></td>
<td>사전식으로 비교하였을 때 '지정 범위' 순열의 바로 다음인 순열을 만들기(사전식으로 이미 마지막이면 <code>false</code>가 반환된다. 추가로 비교 '기준'을 지정하여 줄 수도 있다.)</td>
</tr>
<tr>
<td><code>prev_permutation</code></td>
<td>사전식으로 비교하였을 때 '지정 범위' 순열의 바로 전인 순열을 만들기(사전식으로 이미 처음이면 <code>false</code>가 반환된다. 추가로 비교 '기준'을 지정하여 줄 수도 있다.)</td>
</tr>
</tbody>
</table>
<h4 id="수numeric-연산">수(numeric) 연산</h4>
<table>
<thead>
<tr>
<th>함수</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>iota</code> <sub>C++11</sub></td>
<td>'지정 범위'를 '지정 값'부터 순차로 증가하게 채우기</td>
</tr>
<tr>
<td><code>accumulate</code></td>
<td>'지정 범위' 안에 있는 요소의 값을 '지정 값'(초깃값)에 누적하여 더하고 그렇게 나온 값을 반환시키기(추가로 적용할 '함수'를 지정하여 줄 수도 있다. 그러나 실행 정책을 지정할 수 없다. 예를 들어 '지정 값'이 1이고 '지정 함수'가 <code>std::multiplies&lt;int&gt;()</code>이면 누계가 아니라 누적 곱이 나온다.)</td>
</tr>
<tr>
<td><code>inner_product</code></td>
<td>'지정 범위' 안에 있는 요소들과 '지정 위치'부터 시작하는 범위 안에 있는 요소들을 내적하여 나온 값을 반환시키기(추가로 적용할 <strong>두</strong> '함수'를 지정하여 줄 수도 있는데 첫 함수는 더하기 자리에 적용할 함수를, 두 번째 함수는 곱하기 자리에 적용할 함수를 지정하여야 한다. 예를 들어 '지정 함수들'이 <code>std::plus&lt;&gt;()</code>, <code>std::equal_to&lt;&gt;()</code>이면 동일한 값이 있으면서 상대 위치가 같은 요소가 몇 쌍인지 알 수 있다.)</td>
</tr>
<tr>
<td><code>adjacent_difference</code></td>
<td>'지정 범위' 첫 요소의 값은 그대로 '지정 위치'에 넣고 그 다음부터는 해당 위치 요소 값에서 바로 전 요소의 값을 감산하여 넣기(추가로 적용할 '함수'를 지정하여 줄 수도 있다. 예를 들어 <code>std::plus&lt;&gt; {}</code> 함수를 사용하면 피보나치수열도 만들 수 있다.)</td>
</tr>
<tr>
<td><code>partial_sum</code></td>
<td>'지정 범위' 첫 요소의 값은 그대로 '지정 위치'에 넣고 그 다음부터는 해당 위치 요소 값에 전(前) 요소들의 값을 전부 가산하여 넣기(제곱수를 나열할 때 유용하다. 추가로 적용할 '함수'를 지정하여 줄 수도 있다. 그러나 실행 정책을 지정할 수 없다.)</td>
</tr>
<tr>
<td><code>reduce</code> <sub>C++17</sub></td>
<td>실행 정책<sub>C++17</sub>을 지정하여 병렬 처리가 가능한 <code>std::accumulate</code>(주의: <code>&lt;numeric&gt;</code>에 정의되어 있다. 참고: JavaScript <code>reduce</code>와 유사하다.)</td>
</tr>
<tr>
<td><code>exclusive_scan</code> <sub>C++17</sub></td>
<td>실행 정책<sub>C++17</sub> 지정이 가능하고 계산 시 해당 위치 요소의 값은 포함되지 않는 <code>std::partial_sum</code>(즉 '지정 위치' 첫 요소 값은 초깃값이다.)</td>
</tr>
<tr>
<td><code>inclusive_scan</code> <sub>C++17</sub></td>
<td>실행 정책<sub>C++17</sub> 지정이 가능하고 계산 시 해당 위치 요소의 값이 포함되는 <code>std::partial_sum</code>(즉 '지정 위치' 첫 요소 값은 '지정 범위' 첫 요소 값이다.)</td>
</tr>
<tr>
<td><code>transform_reduce</code> <sub>C++17</sub></td>
<td><code>std::transform</code>, <code>std::reduce</code>를 연달아 사용하기</td>
</tr>
<tr>
<td><code>transform_exclusive_scan</code> <sub>C++17</sub></td>
<td><code>std::transform</code>, <code>std::exclusive_scan</code>을 연달아 사용하기</td>
</tr>
<tr>
<td><code>transform_inclusive_scan</code> <sub>C++17</sub></td>
<td><code>std::transform</code>, <code>std::inclusive_scan</code>을 연달아 사용하기</td>
</tr>
</tbody>
</table>
<h4 id="초기화하지-않은-메모리에-사용하는-연산">초기화하지 않은 메모리에 사용하는 연산</h4>
<table>
<thead>
<tr>
<th>함수</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>uninitialized_copy</code></td>
<td>'지정 범위' 객체들(값들)을 '지정 위치'로 시작하는 초기화하지 않은 메모리 공간에 복사하여 넣기(반환 값은 복사되어 넣어진 마지막 요소의 바로 다음 위치를 가리키는 반복자이다.)</td>
</tr>
<tr>
<td><code>uninitialized_copy_n</code></td>
<td>'지정 범위' 객체들(값들)을 '지정 위치'로 시작하는 초기화하지 않은 메모리 공간에 복사하여 넣기(반환 값은 복사되어 넣어진 마지막 요소의 바로 다음 위치를 가리키는 반복자이다.)</td>
</tr>
<tr>
<td><code>uninitialized_fill</code></td>
<td>초기화하지 않은 '지정 범위' 메모리 공간을 '지정 값'(지정 객체)로 채우기</td>
</tr>
<tr>
<td><code>uninitialized_fill_n</code></td>
<td>초기화하지 않은 '지정 범위' 메모리 공간을 '지정 값'(지정 객체)로 채우기</td>
</tr>
<tr>
<td><code>uninitialized_move</code> <sub>C++17</sub></td>
<td>'지정 범위' 객체들(값들)을 '지정 위치'로 시작하는 초기화하지 않은 메모리 공간으로 이동하기</td>
</tr>
<tr>
<td><code>uninitialized_move_n</code> <sub>C++17</sub></td>
<td>'지정 범위' 객체들(값들)을 '지정 위치'로 시작하는 초기화하지 않은 메모리 공간으로 이동하기</td>
</tr>
<tr>
<td><code>uninitialized_default_construct</code> <sub>C++17</sub></td>
<td>초기화하지 않은 '지정 범위' 메모리 공간에 기본 초기화 방식으로 객체를 생성하기</td>
</tr>
<tr>
<td><code>uninitialized_default_construct_n</code> <sub>C++17</sub></td>
<td>초기화하지 않은 '지정 범위' 메모리 공간에 기본 초기화 방식으로 객체를 생성하기</td>
</tr>
<tr>
<td><code>uninitialized_value_construct</code> <sub>C++17</sub></td>
<td>초기화하지 않은 '지정 범위' 메모리 공간에 값 초기화 방식으로 객체를 생성하기</td>
</tr>
<tr>
<td><code>uninitialized_value_construct_n</code> <sub>C++17</sub></td>
<td>초기화하지 않은 '지정 범위' 메모리 공간에 값 초기화 방식으로 객체를 생성하기</td>
</tr>
<tr>
<td><code>destroy</code> <sub>C++17</sub></td>
<td>'지정 범위' 객체를 소멸시키기</td>
</tr>
<tr>
<td><code>destroy_n</code> <sub>C++17</sub></td>
<td>'지정 범위' 객체를 소멸시키기</td>
</tr>
<tr>
<td><code>destroy_at</code> <sub>C++17</sub></td>
<td>'지정 주소' 객체를 소멸시키기</td>
</tr>
<tr>
<td><code>construct_at</code> <sub>C++20</sub></td>
<td>'지정 주소'에 객체를 생성하기</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="참조">참조</h2>
<p><a href="https://en.cppreference.com/w/" target="_blank" rel="noopener">cppreference.com</a></p>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p> 주소를 담는 객체인 반복자(iterator)로 '위치'를 지정하며, 함수명에 _n이 있을 때에는 시작 위치 반복자와 요소 개수로, _n이 없을 때에는 시작 위치 반복자와 끝 다음 위치 반복자로 '범위'를 지정한다. 함수로 '기준'을 지정한다. <a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2" role="doc-endnote">
<p>'앞부분'과 '뒷부분'은 범위를 <code>begin()</code>, <code>end()</code> 쌍(또는  <code>cbegin()</code>, <code>cend()</code>  쌍)으로 지정하느냐 <code>rbegin()</code>, <code>rend()</code> 쌍(또는 <code>crbegin()</code>, <code>crend()</code> 쌍)으로 지정하느냐에 따라 다르다. <a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:3" role="doc-endnote">
<p>요소 간 상대 순서를 유지한다는 의미로 함수명에 <code>stable</code>이 있다. <a href="#fnref:3" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:4" role="doc-endnote">
<p><a href="https://en.wikipedia.org/wiki/Introsort" target="_blank" rel="noopener">Introsort</a>(<strong>quicksort</strong>, heapsort, insertion sort)가 사용된다고 한다. <a href="#fnref:4" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:5" role="doc-endnote">
<p>Heapsort가 사용된다고 한다. <a href="#fnref:5" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:6" role="doc-endnote">
<p>Bottom-up <strong>merge sort</strong>와 insertion sort가 사용된다고 한다. <a href="#fnref:6" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:7" role="doc-endnote">
<p>우주선 연산자와 관련이 있다. <a href="#fnref:7" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>

		<div id="taxonomies"></div>
<div class="emptyLine"></div>
			
			
				<button id="loadDisqusButton" onclick="loadDisqus()">Load Comments</button>

<script type="text/javascript">
let isOn = 0;
let loadButton = document.getElementById("loadDisqusButton");

function loadDisqus() {
if (isOn === 0) {
(function() {
    
    
    if (window.location.hostname == "localhost")
        return;
    let wrapper = document.createElement('div');
    wrapper.setAttribute("id", "disqus_thread");
    wrapper.async = true;
    document.getElementById('loadDisqusButton').insertAdjacentElement('afterend', wrapper);
    let dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    let disqus_shortname = 'tk0';
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
isOn = 1;
loadButton.style.display = "none";
};
};
</script>
<noscript>
    Please enable JavaScript to view the 
    <a href="https://disqus.com/?ref_noscript" rel="nofollow">
        comments powered by Disqus.
    </a>
</noscript>

			
	</div>

	<div class="pagination">

		<a href="/posts/c&#43;&#43;-%EC%8A%A4%ED%8A%B8%EB%A7%81string/" class="left arrow">&#8592;</a>
		
	</div>
</main>


        <script src="/js/jquery.min.f7f6a5894f1d19ddad6fa392b2ece2c5e578cbf7da4ea805b6885eb6985b6e3d.js" integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin="anonymous"></script><script src="/js/bigfoot_callrightaway.387acf7612f2609f22f980caef353bc3b8f020482b457ece3e6fff5fc9104308.js" integrity="sha256-OHrPdhLyYJ8i&#43;YDK7zU7w7jwIEgrRX7OPm//X8kQQwg=" crossorigin="anonymous"></script>
			
		
		<a id="backtoTopButton" title="Back to top" href="#">↑</a>
		<footer>
			<span>
			<a href="/about/">About</a> | <a href="/privacy/">Privacy Policy</a> | &copy; <time>2021</time> T. Kim. Made with <a href='https://gohugo.io'>Hugo</a> using a modified <a href='https://github.com/EmielH/tale-hugo/'>Tale</a> theme.
			</span>
		</footer>
    </body>
</html>
